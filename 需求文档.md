
二、功能模块
2.1 学生可排课时段设置
2.1.1 数据库设计
新增表: student_available_times
id INTEGER PRIMARY KEY
student_id INTEGER (外键关联students表)
day_of_week INTEGER (0-7, 对应周一到周日)
time_slot INTEGER (1-10, 对应10个时间段)
UNIQUE约束: (student_id, day_of_week, time_slot)
2.1.2 UI交互
位置: 学生管理页面，每个学生卡片新增按钮

按钮: "设置可排课时段"

弹窗内容:

标题: "{学生姓名} - 可排课时段设置"
显示一张空白课表（7天 × 10时段）
支持单击选择/取消单元格
支持鼠标拖拽批量选择
选中的单元格背景色: 绿色 (#dcfce7)
未选中的单元格: 白色
底部按钮: "保存" | "取消"
交互逻辑:

初次打开: 加载该学生已保存的可排课时段
单击空白格: 标记为可排课（变绿）
单击绿色格: 取消可排课（变白）
鼠标拖拽: 批量选择区域
保存: 将选中状态同步到数据库
该设置不影响已有的学生课表导出
2.2 自动排课模块
2.2.1 左侧边栏
新增菜单项: "自动排课"

图标: 建议使用魔法棒或自动化图标
点击后跳转到自动排课页面
2.2.2 页面结构
步骤1: 选择学生

顶部显示学生列表（Dropdown或卡片选择）
选择学生后加载该学生信息和可排课时段
步骤2: 可视化时段展示

显示一张课表（7天 × 10时段）
绿色单元格: 学生的可排课时段
灰色单元格: 教师休息时段（任意教师在该时段休息）
白色单元格: 不可排课（既不在学生可排课时段，也不是休息时段）
已排课程显示在对应单元格（蓝色容器）
步骤3: 课时安排设置

按钮: "课时安排"
点击后弹出设置弹窗
2.2.3 课时安排弹窗
弹窗内容:

标题: 课时安排设置
 
表单字段:
1. 课程 (必填)
   - 下拉选择: 阅读 | 听力 | 写作 | 口语
   
2. 课程类型 (必填)
   - 下拉选择: 一对一 | 网课 | 班课 | 其他
   
3. 本周课时数 (必填)
   - 输入框: 数字类型，步进为2
   - 说明文字: "必须为偶数（一次课为2节）"
   
4. 备注 (可选)
   - 文本域: 支持多行输入
   
按钮: "确定" | "取消"
验证规则:

课程和课程类型必填
一个学生可以添加多条课时安排
存储方式:

临时存储在页面state中
支持添加、编辑、删除多条记录
在生成排课方案前必须至少有一条记录
2.2.4 显示已添加的课时安排
在课时安排按钮下方，以表格形式展示:

| 课程 | 课程类型 | 本周课时数 | 备注 | 操作 |
|------|---------|-----------|------|------|
| 阅读 | 一对一    | 4节       | -    | 编辑/删除 |
| 听力 | 班课    | 2节       | -    | 编辑/删除 |
2.3 生成排课组合
2.3.1 触发按钮
按钮: "生成排课方案"

位置: 课时安排表格下方
前置条件: 至少有一条课时安排
2.3.2 算法逻辑
输入:

学生可排课时段（绿色单元格）
教师休息时段（灰色单元格，排除）
课时安排列表（课程、课程类型、课时数）
约束条件:

时段限制: 只能在绿色单元格排课
连续性: 一个科目一天只能安排连续的2节课
例: 3rd + 4th ✓
例: 3rd + 5th ✗ (跨午休)
例: 阅读 3rd-4th + 阅读 5th-6th ✗ (同科目一天多次)
完整性: 必须排满所有课时
不重叠: 同一时段不能排多门课
连续时段定义:

上午: 1-2, 2-3, 3-4
下午: 5-6, 6-7, 7-8
晚上: 9-10
算法步骤:

识别所有可用的连续2节时段（绿色且不跨午休）
对每门课程，找出所有可能的排课位置
使用回溯算法生成所有可行组合
限制最多生成15种方案（避免组合爆炸）
按某种评分规则排序（如分散度、时间偏好等）
2.3.3 方案展示
UI设计:

以卡片形式展示多个方案
每个卡片包含:
方案编号: "方案1", "方案2"...
小型课表预览（7天 × 10时段，缩略显示）
课程分布情况列表
选择按钮: "选择此方案"
示例:

┌─────────────────────────────────┐
│ 方案1                           │
├─────────────────────────────────┤
│ 周一: 阅读 3rd-4th              │
│ 周三: 听力 5th-6th              │
│ 周五: 阅读 9th-10th             │
├─────────────────────────────────┤
│ [课表缩略图]                     │
│                                 │
│ [ 选择此方案 ]                  │
└─────────────────────────────────┘
2.4 确认并同步到学生课表
2.4.1 选择方案后
弹出二次确认对话框
提示: "确认使用该方案？将覆盖该学生本周的现有排课"
按钮: "确认" | "取消"
2.4.2 同步逻辑
删除: 清空该学生本周的现有排课（仅当前周）
插入: 将方案中的所有课程插入schedules表
student_id: 选中的学生ID
week_start_date: 当前周开始日期
day_of_week: 对应星期
time_slot: 对应时段
subject: 课程名称
course_type: 课程类型
教师分配:
根据学生的科目-教师关系表自动分配教师
如果未设置，teacher_id留空，需要后续手动指定
成功提示: "排课成功！已同步到{学生姓名}的课表"
跳转: 自动跳转到该学生的课表页面查看
2.4.3 后续手动调整
自动排课后，用户可以在学生课表页面:
手动删除某节课
手动添加课程
修改课程信息
调整教师分配
与现有手动排课功能完全兼容
三、数据库变更
3.1 新增表
sql
-- 学生可排课时段
CREATE TABLE student_available_times (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  student_id INTEGER NOT NULL,
  day_of_week INTEGER NOT NULL,
  time_slot INTEGER NOT NULL,
  FOREIGN KEY (student_id) REFERENCES students(id) ON DELETE CASCADE,
  UNIQUE(student_id, day_of_week, time_slot)
);
CREATE INDEX idx_available_times ON student_available_times(student_id);
四、新增API
4.1 学生可排课时段
javascript
// 获取学生可排课时段
getStudentAvailableTimes(studentId)
// 设置学生可排课时段（批量，先清空再插入）
setStudentAvailableTimes(studentId, timesArray)
// timesArray: [{day_of_week, time_slot}, ...]
4.2 自动排课
javascript
// 生成排课方案
generateScheduleOptions({
  studentId,
  weekStartDate,
  courseArrangements // [{subject, courseType, hours, remark}]
})
// 返回: [方案1, 方案2, ...]
// 应用排课方案
applyScheduleOption({
  studentId,
  weekStartDate,
  scheduleOption // 选中的方案对象
})
五、UI组件列表
5.1 新增组件
StudentAvailableTimeModal.jsx - 学生可排课时段设置弹窗
AutoSchedule.jsx - 自动排课主页面
CourseArrangementModal.jsx - 课时安排设置弹窗
ScheduleOptionCard.jsx - 排课方案卡片
SchedulePreview.jsx - 课表缩略预览组件
5.2 修改组件
StudentManagement.jsx - 添加"设置可排课时段"按钮
Sidebar.jsx - 添加"自动排课"菜单项
六、技术难点与注意事项
6.1 排课算法
使用回溯算法生成组合
需要剪枝优化，避免超时
限制方案数量上限
6.2 性能优化
可排课时段较多时，组合数可能爆炸
建议实现计算进度提示或loading状态
6.3 用户体验
拖拽选择时段需要流畅
方案预览要清晰直观
错误提示友好（如无可行方案）
6.4 边界情况
无可行方案时的处理
学生未设置可排课时段
课时数超过可用时段数
所有教师都在某时段休息
七、实现优先级
P0 (核心功能)
学生可排课时段设置
自动排课页面基础框架
课时安排设置
简单的排课算法（生成1-2个方案）
方案同步到课表
P1 (增强功能)
拖拽批量选择时段
优化算法，生成多个方案
方案评分排序
课表缩略预览
P2 (优化功能)
算法性能优化
更智能的教师分配
方案对比功能
历史方案保存
八、测试用例
8.1 基础功能
设置学生可排课时段并保存
添加课时安排
生成至少一个可行方案
应用方案并查看学生课表
8.2 边界情况
学生无可排课时段
课时数为0或负数
课时数为奇数（应提示错误）
可用时段不足以排下所有课时
8.3 约束验证
同一科目一天不能排两次
不能跨午休排课
不能在灰色（教师休息）时段排课

逻辑漏洞分析与解决方案
问题描述
当前逻辑缺陷：

学生A有多个科目（阅读、听力、写作、口语），每个科目对应不同教师
某时段：听力教师休息，但阅读/写作/口语教师都在
当前行为：该时段被标记为灰色（教师休息），完全禁止排课
期望行为：该时段仍可排阅读/写作/口语，只是不能排听力
根本原因
autoScheduleService.js:35-43：

javascript
function getTeacherOffDays(weekStartDate) {
  const db = getDatabase();
  const stmt = db.prepare(`
    SELECT day_of_week, time_slot FROM teacher_off_days
    WHERE week_start_date = ?
  `);
  return stmt.all(weekStartDate);
}
获取了所有教师的休息时段，未区分具体教师
在 filterUsableSlots 中，只要有任何教师休息就排除该时段
解决方案
方案A：精细化过滤（推荐）
修改后端算法逻辑：

获取学生的科目-教师绑定
javascript
function getStudentTeacherMap(studentId) {
  const db = getDatabase();
  const stmt = db.prepare(`
    SELECT subject, teacher_id FROM student_teacher_subjects
    WHERE student_id = ?
  `);
  return stmt.all(studentId);
}
获取教师休息时段时保留教师ID
javascript
function getTeacherOffDays(weekStartDate) {
  const stmt = db.prepare(`
    SELECT teacher_id, day_of_week, time_slot 
    FROM teacher_off_days
    WHERE week_start_date = ?
  `);
  return stmt.all(weekStartDate);
}
在回溯算法中动态检查
不再全局过滤掉教师休息时段
为每门课程寻找时段时，只检查该科目对应教师是否休息
javascript
// 伪代码
for (const slot of allAvailableSlots) {
  const teacherId = teacherMap[course.subject];
  const isTeacherOff = teacherOffDays.some(
    od => od.teacher_id === teacherId && 
          od.day_of_week === slot.day && 
          od.time_slot === slot.timeSlot
  );
  if (isTeacherOff) continue; // 该教师休息，跳过
  // 否则可以排课
}
前端展示优化：

灰色时段改为"部分教师休息"
或显示具体哪些教师休息（悬浮提示）

2.生成方案时，点击该方案应该可以查看可视化预览
3.休息日写明哪个教师休息，如灰色格子里教师A-休息，教师B-休息，不休息的不用写进去